<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pirâmide WebGL Pura</title>

<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: black;
    }
    canvas {
        width: 100vw;
        height: 100vh;
        display: block;
        touch-action: none;
    }
</style>
</head>
<body>

<canvas id="glcanvas"></canvas>

<script>
/* =======================
   CONFIGURAÇÃO DO WEBGL
   ======================= */
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl", { antialias: true });

if (!gl) {
    alert("WebGL não suportado");
}

/* Ajusta para tela cheia */
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
}
window.onresize = resize;
resize();

/* ============================
   SHADERS (VERTEX + FRAGMENT)
   ============================ */
const vsSource = `
attribute vec3 position;
attribute vec3 color;
uniform mat4 mvp;
varying vec3 vColor;
void main() {
    gl_Position = mvp * vec4(position, 1.0);
    vColor = color;
}
`;

const fsSource = `
precision mediump float;
varying vec3 vColor;
void main() {
    gl_FragColor = vec4(vColor, 1.0);
}
`;

/* Compila shader */
function compile(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

const vertexShader = compile(gl.VERTEX_SHADER, vsSource);
const fragmentShader = compile(gl.FRAGMENT_SHADER, fsSource);

/* Monta programa */
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

/* =======================
   PIRÂMIDE (GEOMETRIA)
   ======================= */
const vertices = new Float32Array([
    // Base (quadrado)
    -1, 0, -1,   1, 0, 0,
     1, 0, -1,   0, 1, 0,
     1, 0,  1,   0, 0, 1,
    -1, 0,  1,   1, 1, 0,

    // Topo
     0, 2, 0,    1, 0, 1,
]);

const indices = new Uint16Array([
    0,1,2,
    0,2,3,

    // laterais
    0,1,4,
    1,2,4,
    2,3,4,
    3,0,4
]);

/* Buffer de vértices */
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

/* Buffer de índices */
const ibo = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

/* Atributos */
const stride = 6 * 4;
const posLoc = gl.getAttribLocation(program, "position");
gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, stride, 0);
gl.enableVertexAttribArray(posLoc);

const colLoc = gl.getAttribLocation(program, "color");
gl.vertexAttribPointer(colLoc, 3, gl.FLOAT, false, stride, 12);
gl.enableVertexAttribArray(colLoc);

/* =======================
   MATRIZES 3D
   ======================= */
function matMul(a, b) {
    const o = new Array(16);
    for (let i = 0; i < 4; i++)
        for (let j = 0; j < 4; j++)
            o[i*4+j] = a[i*4+0]*b[0*4+j] + a[i*4+1]*b[1*4+j] + a[i*4+2]*b[2*4+j] + a[i*4+3]*b[3*4+j];
    return o;
}

function perspective(fov, aspect, near, far) {
    const f = 1 / Math.tan(fov / 2);
    return [
        f/aspect,0,0,0,
        0,f,0,0,
        0,0,(far+near)/(near-far),-1,
        0,0,(2*far*near)/(near-far),0
    ];
}

function translate(x,y,z) {
    return [
        1,0,0,0,
        0,1,0,0,
        0,0,1,0,
        x,y,z,1
    ];
}

function rotateY(a) {
    return [
        Math.cos(a),0,Math.sin(a),0,
        0,1,0,0,
        -Math.sin(a),0,Math.cos(a),0,
        0,0,0,1
    ];
}

/* =======================
   INTERAÇÃO DE TOQUE
   ======================= */
let rot = 0;
let dragging = false;
let oldX = 0;

canvas.addEventListener("touchstart", e => {
    dragging = true;
    oldX = e.touches[0].clientX;
});

canvas.addEventListener("touchmove", e => {
    if (dragging) {
        const x = e.touches[0].clientX;
        rot += (x - oldX) * 0.01;
        oldX = x;
    }
});

canvas.addEventListener("touchend", () => dragging = false);

/* =======================
   LOOP DE RENDERIZAÇÃO
   ======================= */
const mvpLoc = gl.getUniformLocation(program, "mvp");

function render() {
    rot += 0.01;

    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);

    const proj = perspective(Math.PI/3, canvas.width/canvas.height, 0.1, 100);
    const view = translate(0,-1,-6);
    const model = rotateY(rot);

    const mvp = matMul(matMul(proj, view), model);

    gl.uniformMatrix4fv(mvpLoc, false, new Float32Array(mvp));
    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

    requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
